
# Getting started

A CADET-RDM repository typically consists of a `project repository` which contains the code and an `output repository` which contains the results generated by the project code. By initializing an RDM repository, the necessary file structure for tracking and version-controlling the project and the output will be created.

The following paragraphs contain a short guide to quickly start working with CADET-RDM. Almost all tools can be used either by running specific command line prompts or by executing code in python.

## Initialize RDM-Repositories

Start using CADET-RDM by creating a new project repository or converting an existing repository into a CADET-RDM repository.
```bash
rdm init <path-to-repo>
```

or from python

```python
from cadetrdm import initialize_repo

initialize_repo(path_to_repo)
```
- If no `<path-to-repo>` is provided, the repository is initialized in the root directory without creating a new directory.
- If `<path-to-repo>` is given as a relative path (e.g. "repository_name"), a new directory with that name is created inside the root directory.
- If `<path-to-repo>` is given as an absolute path (e.g. C:\Users\me\projects\myrepo), a new directory is created at the specified location.

The initialization of the RDM repository will generate a **project repository** containing the following contents, should they not have previously existed within the directory:

```bash
.git
output
.cadet-rdm-cache.json
.cadet-rdm-data.json
.gitignore
Dockerfile
environment.yml
jupytext.yml
README.md
```

The **output repository** for storing and tracking the results of the project is also generated at initialization. It is created as a directory inside of the project repository. Both the project repository and the output repository are their own separate git repositories.
The `output_directory_name` can be specified optionally. It defaults to `output`. The output directory is initialized with the following contents:

```bash
.git
.cadet-rdm-data.json
.gitattributes
.gitignore
README.md
```
With every run of the project code, a new output branch with the results of the run is created. At the same time, the main branch of the output repository tracks these runs in the `run_history` directory. Every branch has its own sub-directory in the run_history directory. Within this branch, the following files are stored for every run:

    conda_environment.yml
    conda_independent_environment.yml
    metadata.json
    pip_independent_requirements.txt
    pip_requirements.txt

The information stored in these files can be used to reproduce the specific output created by running the project code with these configurations.

## Cookiecutter support

[Cookiecutter](https://github.com/cookiecutter/cookiecutter) can be used to set a template as a starting position for the repository initialization.
If `<path-to-repo>` is given as an absolute or relative path, it overwrites the name which may be given to the directory in the cookiecutter prompt. If no `<path-to-repo>` is provided, the repository is initialized in the root directory. No new directory is created, even if the cookiecutter template would normally do so.

From the command line

```bash
rdm init <path-to-repo> --cookiecutter <template_url>
```

or from python

```python
from cadetrdm import initialize_repo

initialize_repo(path_to_repo, cookiecutter_template="template_url")
```


## Creating remote repositories automatically

Remotes for both the project and the output repository can be created with one command, using the GitLab or GitHub API.

A
[GitLab Personal Access Token (PAT)](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html) or [GitHub PAT](https://github.com/settings/tokens?type=beta) with API access rights has to be created
and stored in the Python `keyring` using an interactive Python session:

```python
import keyring

keyring.set_password("e.g. https://jugit.fz-juelich.de/", "username", "token")
```

or in a command line

````bash
keyring set "e.g. https://jugit.fz-juelich.de/" <username>
````

Then the following code is run to automatically create remotes for both the project repository and the output repository at the chosen URL:

```python
from cadetrdm import ProjectRepo

repo = ProjectRepo()

repo.create_remotes(
    name="e.g. API_test_project",
    namespace="e.g. r.jaepel",
    url="e.g. https://jugit.fz-juelich.de/",
    username="e.g. r.jaepel"
)
```

or in a command line

```bash
rdm remote create <url> <namespace> <name> <username>
```
e.g.
```bash
rdm remote create https://jugit.fz-juelich.de/ r.jaepel API_test_project r.jaepel
```

The name of the created output remote is derived from the respective project repository name by appending `_output`, "e.g. API_test_project_output".


## Adding remote repositories

To share the project code and results (*output*) with others, remote repositories have to be configured on e.g.
[GitHub](https://github.com/) or GitLab. Remotes for both the `project_repository` and the
`output_repository` have to be created.

Once created, the remotes need to be added to the local repositories. Run the following commands in both repositories with their respective `remote_url`s.

```bash
rdm remote add <remote_url>
```
e.g.

```bash
cd project
rdm remote add git@<my_git_server.foo>:<project>.git
cd output
rdm remote add git@<my_git_server.foo>:<project>_output.git
```

## Staging, committing and pushing changes to the remote repositories

To check that all remotes are set correctly, the metadata is consistent and stage all changes within the project and output repository, run the following command in the project repository:

```bash
rdm check
```
To commit the staged changes run the following command in the project repository:

```bash
rdm commit -m <message>
```
To then push all commits from project and output repository, run the following command in the project repository:

```bash
rdm push
```